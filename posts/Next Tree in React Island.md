# Next Tree in React Island

Arrival :

들어가기에 앞서
라이징 스타 자바 스크립트(https://risingstars.js.org/2024/en)에서도 
단연 상위권 랭커로 달리고 있는 그...
도대체 어떻게나 이렇게 많은 사랑을 받았을까요?
바로 Next.js는 라이브러리가 아닌 프레임워크기 때문입니다.
그럼 리액트는 라이브러리인데, 그럼 둘의 차이는 뭐지? 싶은데,
프레임 워크와 라이브러리는 기능 구현 주도권에 따라 구분됩니다. 
프레임 워크는 자유도가 낮고 거의 모든 기능을 제공하고 있습니다.
(페이지라우팅, 최적화, 서버 사이드 렌더링... )
근데 라이브러리는 자유도 높고 거의 일일이 구현해야하죠.
결국 Next.js는 리액트를 더 편하게 쓰기 위해 만들어진 거 같아요.

이제 Next.js의 
사전 렌더링
페이지 라우팅
빌트인 최적화
*다이나믹 HTML 스트리밍 *
핵심 개념 4가지를 알아가봅니다. 
사전 렌더링
= 빠른 FCP 달성 + 빠른 페이지 이동
사전 렌더링이란 브라우저의 요청에 대하여 사전에 렌더링이 완료된 HTML을 응답하는 렌더링 방식을 뜻합니다. 
Client Side Rendering
리액트가 따르는 렌더링 방식으로 클라이언트에서 직접 화면을 렌더링한다
구조화를 해보면, 
사람 🙋🏻 / 클라이언트 🖥️ / 서버 🏢 가 있다고 할 때,
서버가 브라우저에게 빈껍데기를 보내게되면
브라우저는 서버로부터 받은 파일을 화면에 렌더링하게 됩니다. 
이때 사용자에게 빈껍데기 파일을 보냅니다. 
그럼 아무것도 안나오니까 서버에서는 Js Bundle 파일을 보내주게 되고,
브라우저는 그 번들링 파일을 직접 실행해서 리액트 컴포넌트가 되어 
렌더링을 하여 결과적으로 사용자에게 보내게 되는 것입니다. 
페이지 이동 요청이 사용자로부터 오더라도 
번들링 파일로 컴포넌트만 갈아끼우면 되어서 쾌적하게 페이지 이동을 제공한다는 장점이 있습니다. 
그.러.나 
단점은 존재합니다. 
치명적인 단점인 초기 접속 속도가 느리다는 것입니다. 
왜냐하면 브라우저가 일이 많잖아요.
사용자의 요청으로부터 브라우저 로딩까지 걸리는 시간을 FCP라고 하는데,
이게 높아서 좋을게 하나도 없습니다. 
사용자 이탈률이 높아지거든요.
결국 CSR은 페이지 이동이 매우 빠르고 쾌적합니다. 
그러나 FCP가 높습니다.
그.래.서 Next.js는 리액트의 문제를 해결하게되었어요.
Server Side Rendering
Next.js가 따르는 렌더링 방식으로 서버가 완전히 HTML을 생성 후 클라이언트에게 보낸다.
서버에게 요청을 보냈을 때 
서버에서는 리액트 앱을 직접 실행시켜서 우리가 만든 것들을 다 HTML로 변환하고,
렌더링이 되었다면 그 HTML을 브라우저에게 보내주게됩니다. 
그 렌더링된 HTML을 브라우저에게 바로 보내주게 되니 브라우저가 할 일이 없고,
그걸 바로 화면에 렌더링 시키기만 하면 됩니다. 
그러니 초기 로딩이 빨라지겠죠?
그렇게 FCP가 줄어드는 겁니다. 
서버로부터 딸랑 렌더링된 HTML을 받았다고 끝나는 건 아니고, 
첫 렌더링때는 이벤트같은 걸 처리할 순 없어서 완성된 건 아닙니다! 
웹에서 상호작용까지 되기 위해 서버는 JS Bundle 파일을 또 보내줍니다. 
그러면 브라우저는 받은 HTML과 번들링을 연결하여서 메마른 땅에 비가 내리듯 물이 떨어져서 
상호작용까지 가능해진 생기있는 HTML이 되는데, 바로 수화(Hydration) 상태가 되어 완성되게 됩니다. 
이를 TTI라고 하는데 "요청부터 Hydration까지 TTI 2초 걸렸다." 라고 표현하기도 합니다. 
라우팅
페이지 라우터와 앱라우터차이
구 버전라우터 Next13버전부터 공개된 신규라투ㅇ라 다양한 신규 기능이 제공된다.. 서버 컴포넌트등 
최신기능이 좋을테니 페이지 라우터를 배울 필요는 없지않을까?싶지만
배워야하는 이유는
페이지라우터의 단점을 보완하기위해 앱라우터가 나온거라, 뭘 개선한건지 나아진건지 파악이 어렵다.
앱라우터는 과도기를 겪고 있다 버그가 있다 뻐그
그러니 페이지라우터 듣자(지금은 말고)
앱 라우터
앱 라우터란 Next 13버전부터 공개된 신규 라우터로 다양한 신규기능을 제공하고 있습니다.
페이지 라우터를 사용할 때와 달리 앱 라우터를 사용하면 
폴더구조가 src/page에서 src/app으로 변경됩니다.
그래서 page.tsx는 페이지 파일, layout.tsx는 레이아웃 파일이 됩니다.
페이지 라우터일 때는 페이지 자체가(index제외, /) 페이지의 라우터가 됐다면, 
앱 라우터부터는 page.tsx만 페이지 자체만 필요하고, 
search 라우터가 필요하다면 search 폴더에 page.tsx가 페이지가 됩니다
1. 앱 라우터의 구조
ex) src/app/bood/[id]/page.tsx
export default async function Page({
  params//나는 props에서 params만 쓸 것이다
}:{ params: Promise<{q: string}>}// params는 프로미스에서 객체형태로 오는데 q라는 키를 가지고 있고 값은 string 타입이다.
){
  let {q} = await params;//구조분해할당으로 q를 꺼낸다
}
동적 라우트를 이용해서 /book/1 /book/2 ... 페이지들로 이동합니다. 
단, [id]로는 book 페이지를 이동할 수가 없어서 만약, book페이지 이동이 필요하다면 캐치올 세그먼트로, 어쩌구저쩌구라면 옵셔널 세그먼트를 사용합니다.
캐치올세그먼트: [...id]
옵셔널세그먼트: [[...id]]
2. 레이이웃 설정
레이아웃은 말 그대로 페이지 컴포넌트의 레이아웃을 뜻합니다.
레이아웃을 설정할 때 파일 이름은 layout.tsx로 설정하며,
레이아웃은 중첩이 가능합니다.

3. 라우트 그룹
라우트 그룹은 app 폴더 내 소괄호로 묶인 이름 ex) (with-searchBar)으로 된 폴더를 말합니다.
경로상에는 아무런 영향도 주지 않으면서 동시에 각기 다른 경로를 갖는 파일들을 모을 수 있습니다. 그래서 레이아웃만 동일하게 적용합니다
4. 리액트 서버 컴포넌트(RSC)
왜 필요할까요
: 페이지 라우터를 생각해보면 렌더링 과정에서 수화가 필요하지 않은 것들까지 JSBundle에 포함하다보니 TTI가 길어졌다. 그렇다면 번들에서 수화가 필요없는 컴포넌트들을 빼면 된다. 그래서 나오게 됩니다.
React Server Component
: 서버측에서 사전 렌더링 시 딱 한번 실행되는 컴포넌트
cf) Client Component - 두번 실행되는 컴포넌트(사전렌더링, 수화시)
그래서 리액트 공식 홈페이지는 페이지의 대부분을 서버 컴포넌트로 구성할 것을 권장하며, 클라이언트 컴포넌트는 꼭 필요한 경우 사용하라고 명시되어있습니다.
기본적으로 컴포넌트는 만들어지면 서버 컴포넌트입니다. 
그렇다면 어떤 컴포넌트를 클라이언트 컴포넌트로 만들어야할까요?
단순하게 서버와 상호작용이 있는 지의 유무에 따라 선택하면 됩니다.
RSC 주의사항
서버컴포넌트는 클라이언트에서 실행될 코드가 들어가면 안됩니다.
클라이언트 컴포넌트는 클라이언트에서만 실행되지 않는다 > 서버측에서 한번, 클라이언트에서 한번(하이드레이션시)
클라이언트 컴포넌트에서 서버 컴포넌트를 Import 할 수 없다 > 왜냐하면 넥스트가 내부적으로 서버 컴포넌트를 클라이언트로 바꿔버리기 때문입니다.
최대한 피해야하는 상황

만약~ 반드시 이렇게 둬야한다! 한다면, 
import는 지우고 props로 넘기면 Next.js는 해당 자식 컴포넌트를 클라이언트 컴포넌트로 넘기지 않게 됩니다.
서버 컴포넌트에서 클라이언트에게 직렬화 되지 않는 Props는 전달 불가
직렬화 : 어쩌구 저쩌구 문자열이나 바이트로 전달되는 방식을 말하는데 자바는 직렬화가 되지만 자바스크립트는 직렬화가 불가능합니다. 왜냐하면 코드블럭의 형태를 띄고 있는 구조이기도 하고요, 심지어는 클로저나 렉시컬스코프같은 다양한 환경에 의존하기 때문입니다. 그런 형태를 단순하게 만들기가 어렵고, 즉 함수는 직렬화가 불가해서 서버에게 Props로 전달이 불가한 것입니다.
RSC Payload : 라액트18에 도입된 개념으로, 리액트 컴포넌트를 직렬화한 결과인 문자열을 뜻하며, 사전 렌더링 과정중 서버 컴포넌트들만 따로 실행하는 과정에서 렌더링 결과를 직렬화된 형태로 클라이언트에게 전달하는 것을 뜻합니다. 그래서 서버 컴포넌트의 렌더링 결과, 연결된 클라이언트 컴포넌트 위치 클라이언트 컴포넌트에게 전달하는 props값등 모든 정보가 담긴다. 
네비게이팅 
페이지 라우터나 앱 라우터나 페이지 이동은 클라이언트 사이드 렌더링 방식으로 실행됩니다. - 페이지라우터때는 페이지 첫 로딩 이전에 번들을 전달하고자 프리페칭까지 동작한다
프리페칭: 이동할 페이지의 데이터를 미리 불러오는 기능
이때 클라이언트 관련 거만 전달합니다.
그런데 앱 라우터부터는 달라집니다.
프리페칭 시 RSC Payload도 전달하게 됩니다. 그래서 페이지 이동 요청이 오면 Js Bundle 그러니까 클라이언트 컴포넌트와 RSC Payload 서버컴포넌트를 함께 전달하고 클라이언트는 이를 실행시키면서 페이지 교체를 할 수 있게 됩니다.
그러면 테스트해볼까요?
http://localhost:3000/search 이 경로로 이동 후 개발자 도구 Network 탭의 fetch/XHR 부분을 보면 search?_rsc= 가 찍혀있다 이 것은 RSC payload를 뜻하고 search 컴포넌트가 서버 컴포넌트라는 의미입니다. 
Js bundle 파일은 왜 없을까요? 이유는 그저 자바스크립트 이벤트같은 코드가 없어서입니다. 그래서 그냥 안준거에요.
그래서 실습을 해보면
갑자기 루트 레이아웃 파일에 children 위에 header를 만들더니 거기에 Link 태그를 만들어서 여러개 만든다 이거는 페이지 라우터와동일하다고 한다 나는 페이지라우터를 안봤는데 아무튼 근데 대충 링크 버튼 만드는 거인듯
5.네비게이팅
네비게이팅이란 사용자의 페이지간 이동할 때의 동작을 의미합니다. 일반적인 웹앱은 페이지 전환시 새로고침이 일어나지만, Next.js는 클라이언트 사이드 라우팅을 통해 빠르고 부드럽게 이동할 수 있어요.
기본 네비게이팅 
프로그래매틱 네비게이션 useRouter.push
동적으로 페이지 이동 시(조건부) 사용합니다
프리페칭
: 프리페칭이란 연결 가능성있는 모든 페이지를 미리 불러오는 것으로, 사용자가 링크를 hover하거나 할 때 미리 다음 페이지의 리소스를 다운로드 해서 클릭 시 빠르게 이동하게 하는 방법입니다.
npm run build시 로그를 보면,
페이지가 두가지로 나뉘어 있죠?(◌, f)
페이지는 기본적으로 정적 페이지로 만들어지지만,
페이지 내부에서 쿼리스트링이나 URL 파라미터등을 가져온다면 동적 페이지로 설정이 됩니다.
정적(Static) 페이지는 RSX, JS를 둘다 가져오고,
동적(Dynamic)은 나중에 또 가져올 수 있으니 RSC만 가져와요. 즉 동적 페이지는 지바스크립트 번들을 프리 페칭하지 않습니다.
cf) SSG(Static Site Generation) 
: 빌드 타임에 HTML을 미리 생성해두고, 사용자에게는 이미 만들어진 HTML을 보내주어 빠르지만, 데이터가 고정됩닏. 자주 바뀌는 데이터가 담긴 페이지에는 부적절한 방식입니다. 
페이지 라우터의 경우 getStaticProps, getStaticPaths를 사용한 페이지가 해당됩니다.
6. 데이터 페칭
앱 라우터 부터는 getStaticProps, getStaticPaths, getServerProps같은 함수를 사용하지 않게 되었어요. 저 함수들 자체가 데이터를 페칭하기 위한 함수였고 Context Api와 props를 통해서 가져오곤 했지만 이제는 직접 가져올 수가 있게 되었어요.

[Read more](https://velog.io/@deepsea/Next-Island)