# React Island

리액트란 무엇인가?
복잡한 사용자 인터페이스 구축을 효율적으로 관리하기 위해서 
만들어진 라이브러리로 메타에서 개발되었습니다.
배경은 이렇습니다. 
2011년 페이스북에서 피드와 광고 시스템의 상태 관리를 해결하려고 만들었고 
2013년에 오픈소스로 공개되었어요.
아무래도 웹앱이 시간이 지날 수록 기능이 많아지고 인터랙션도 복잡해지니, 
사용자의 행동에 따라서 앱 내부 상태를 바꾸고 그에 따른 화면도 바꿔야했는데 
이를 해결하려고 만든 방식이 상태기반의 선언형 프로그래밍이었던 리액트입니다. 
뿐만 아니라 빠르고 예측 가능한 렌더링을 위해서 
Virtual DOM을 도입하고 실제 DOM 변경을 최소화하면서 성능을 최적화시켰어요. 
그리고 UI를 작은 컴포넌트 단위로 분리하면서 재사용성과 유지보수성을 높이고,
모든 UI를 컴포넌트로 쪼개고 조합하겠다는 패러다임을 표준으로 도입한 라이브러리로
결국 컴포넌트 기반 아키텍쳐를 통해서 UI 렌더링을 효율적인 구조로 관리하면서 
우리 정말 UI 렌더링 제대로 해보자 하면서 나오게 됐습니다.
리액트의 내부 구조

리액트는 Reconciler와 Virtual DOM, 
사람으로 치면 전두엽과 해마를 통해서 이전 상태를 기억해서 비교한 후! 
어떤 변화가 필요한 지 판단을 내리고 
Fiber 즉 신경망을 따라서 어떤 우선순위로 처리할지 조절해서 그 처리 결과를 따라 
Renderer 운동신경을 주체하는 소뇌를 통해 행동하게 되는 뇌와 비슷한 구조를 따릅니다.
리액트의 특징
1. 컴포넌트 기반 UI 표현
중복코드를 줄이면서 재사용성, 유지보수성을 높였습니다.
2. 선언형 프로그래밍
과정은 생략하고 목적만 간결히 명시하는 방식으로 간결해졌습니다.
"돔에 특정 클래스 엘리먼트를 가져온다. 
그 안에 li 엘리먼트를 그린다. 버튼을 삽입한다..." 
이런식으로 일일이 나열하는 게 아닌
우리는 단지 버튼을 렌더링 하겠다. 버튼을 누르면 버튼을 업데이트하겠다. 라고 선언합니다. 
즉 DOM을 어떻게 수정할 지 직접 다루지 않습니다. 
왜냐하면 상태가 바뀌면 알아서 UI가 그려지기 때문입니다.
cf) 명령형 프로그래밍 : 목적을 이루기 위한 모든 일련의 과정을 일일이 설명하는 방식
3. 빠른 화면 업데이트
Critical Rendering Path의 과정에서 다양한 업데이트가 일어납니다.
사람이 직접 DOM 요소를 직접 삽입하고 CSS의 변화를 수동으로 일일이 찾아서 처리를 했었는데,
이제는 Virtual DOM이 알아서 해주거나 state 변경에 따라서 자동 적용이 되게 되었습니다.
예를 들어서 상태 변화가 감지되면 바로 실제 DOM에 변경시키는 게 아니라
가상 DOM이 잠깐 기다려봐 하면서 diffing을 하게 되고 변경된 부분만 Reconcilation 후 반영됩니다. 
리액트의 라이프사이클
탄생(Mount) : 첫 렌더링 
변화(Update) : 리렌더링
죽음(Unmount) : 화면에서 소멸
렌더링시 일어나는 일
컴포넌트 함수 전체가 다시 실행됩니다. 함수는 전체 재실행이지만 실제로는 최소 변경만 반영합니다.
모든 훅을 호출합니다. 단 useRef, useState는 재실행해도 값이 유지됩니다.
JSX는 React.createElement로 변환되고 새로운 객체 트리가 생성됩니다.
이전 가상 DOM과 diffing하고 변경점을 찾습니다. 
이 모든 과정이 처리되고 렌더링 이후 Commit 단계에서 실제 DOM이 변경됩니다. 
리액트의 파일 구조 규칙
하나의 파일에는 하나의 컴포넌트만 작성합니다.
//post.tsx 
export default function post(){
 return <div></div>
}
훅에는 use로 시작하는 함수들만 작성합니다. 여러개의 훅이 한 파일에 있을 수 있습니다.
리액트 훅
함수형 컴포넌트에서 생명주기나 상태 기능을 사용할 수 있게 해주는 함수들을 뜻합니다.
리액트 훅의 규칙
React 함수 내부 에서만 호출
예를 들어 useRouter를 함수 외부에 호출할 경우 훅이 정상적으로 동작하지 않는다.
모듈 레벨()에서는 React Context가 없기 때문입니다.
각 훅은 내부 최상위에 호출해야합니다.
이벤트 핸들러에 훅 호출 못함.
조건부 훅 호출 금지
훅은 항상 호출되어야하며, 내부에서 조건으로 처리해야한다.
if(isAuthenticated){
const { myPots } = useMyPots(true);
}
훅을 정리해보자
React 16까지는 클래스 컴포넌트에서만 상태관리가 가능했습니다.
이후 훅이 나오게 되면서 함수형 컴포넌트에서도 상태관리를 하게 되었어요.
useState
useState는 React가 컴포넌트마다 만들어주는 상태 저장소입니다.
const [count, setCount] = useState(0);
위 코드의 해석을 해보자면 
*useState는 렌더링마다 호출되지만, 초기값 0은 초기에 한번만 적용됩니다. 
count는 React 내부 state 저장소의 값이며, setCount()로만 변경할 수 있습니다.
*라는 뜻입니다. 
useState를 쓰는 이유는 다음과 같습니다.
상태관리
컴포너트 내에서 상태를 저장하고 상태 변경시 컴포넌트를 리렌더링해주는 UI와 상태의 고리역할을 하는 훅입니다.
state값 재생성 방지 및 안정화
리렌더링되더라도 useState로 선언한 변수는 리액트 내부값(React Fiber)을 그대로 사용합니다.
그렇기 때문에 컴포넌트가 리렌더링 되어도 재생성이 되지 않고 초기값으로 덮어씌워지지 않아 상태의 안정성를 유지합니다.
성능 최적화
useState내에서 콜백함수화 후 첫 렌더링시에만 실행되도록 설정하는 Lazy 초기화가 가능합니다.
적절한 사용법과 부적절한 사용법
//리렌더링 마다 생성 
//: state는 유지되고 객체 생성은 낭비
//: 아래 예는 잘못되었지만, 리렌더링마다 객체 생성이 필요할 경우에는 사용
const [queryClient1] = useState(new QueryClient());

//초기화 함수 
//: 초기 렌더링만 필요할 경우 또는 계산 로직이 필요할 경우 사용
const [queryClient2] = useState(() => new QueryClient());
useEffect
useEffect란 부수효과를 처리하는 사이드 이펙트 처리기입니다. 
useEffect(()=>{
    //부수효과 처리
}, [의존성 배열]);
여기서 말하는 부수효과란 컴포넌트 렌더링 외부에서 일어나는 작업들을 뜻합니다. 
즉 아래 같이 렌더링과 연관없는 React의 순수함수적 렌더링 흐름을 벗어나는 작업들에 사용합니다.
외부 API 호출
외부 라이브러리 초기화
타이머 설정
이벤트 리스너 등록
DOM 조작
로컬 스토리지 접근
그리고 이런 작업들이 있을 때, 의존성 배열에 따라 렌더합니다.
[] : 빈배열의 경우 컴포넌트의 마운트 시 1회 실행
[key] : 의존성 값이 있을 경우 해당 값이 변경될 때 마다 실행
없음 : 매 렌더링 마다 실행
cf) 클린업 함수
useEffect 내에서 언마운트되거나 초기로딩을 제외한 의존성 배열이 변경될 때 실행됩니다. 메모리 누수 방지용으로 사용합니다.
useEffect(() => {
...

  const listener = window.naver.maps.Event.addListener(map, 'click', handleMapClick);

  return () => {
      if (listener) {
          window.naver.maps.Event.removeListener(listener);
      }
  };
}, [map, manualLocationMode, currentLocationMarker]);
useRef 돔 참조 및 값 유지
useRef는 DOM요소에 접근하거나 렌더링과 관계없이 값을 저장할 때 사용합니다.
즉 컴포넌트 인스턴스가 살아있는 동안 한번만 초기화됩니다.
상태변화에 따라 리렌더링되어도 끄떡없습니다.
그래서 React에서 값을 저장해주는 잠금장치가진 상자같아요.
그래서 컴포넌트가 언마운트되면 잠금 해제되고 다시 마운트됐을 때 잠금이 활성화되겠죠!
function FocusInput() {
  const inputRef = useRef<HTMLInputElement>(null);

  const handleClick = () => {
    inputRef.current?.focus();
  };

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>Focus</button>
    </>
  );
}

*current : useRef로 연결된 실제 DOM 요소를 가리키는 속성
useReducer
useReducer는 여러 값으로 분기해야 하는 액션이 있거나 복잡한 상태 로직을 관리하고자 할 때 사용합니다.
useMemo
useMemo는 계산 비용이 큰 값을 메모제이션(캐싱)하고 의존성이 변경되지 않으면 이전에 계산된 값을 재사용하는 똑똑한 훅입니다.
즉 의존성 배열이 변경될 때에만 다시 계산합니다.
처음에 했던 오해는 useMemo가 부분 렌더링인가? 라는 오해를 했었지만 전혀 관계가 없이 캐싱을 똑똑하게 하는지에 있었습니다.
결국 똑똑하게 캐싱을 하다보니, 계산을 스킵해서 CPU를 절약하고, 재사용으로 메모리 효율을 높이며 불필요한 연산을 방지해서 성능을 향상시킵니다.
function CreatePotModal() {
  console.log('모달 렌더링 시작'); // ← 항상 실행

  // 이미지만 바뀌었을 때:
  const isFormValid = useMemo(() => {
    console.log('폼 유효성 검사'); // ← 실행 안 됨!
    return /* 복잡한 검사 로직 */;
  }, [formData.title, formData.description, /*...*/]);

  console.log('모달 렌더링 끝'); // ← 항상 실행

  return <Modal>...</Modal>;
}
useCallback
useCallback은 함수를 메모제이션하고 불필요한 함수의 재생성을 막는, useMemo를 이어 똑똑한 훅입니다.
주로 
자주 변경되지 않는 핸들러
조건부 로직이 있는 핸들러
React.memo로 래핑된 자식 컴포넌트에 props로 전달하는 함수
의존성이 거의 변하지 않는 함수
무거운 연산을 포함한 함수
Custom hook에서 반환하는 함수
에서 유용합니다.
*실무에서의 접근 법 : 먼저 useCallback없이 코드를 작성 후 성능 문제시 프로파일링 병목지점을 찾고 나서 최적화
useContext
useContext는 Context API를 사용할 수 있게 해주는 훅으로, 컴포넌트 트리 어디에서든 전역 데이터에 접근할 수 있게하는 훅입니다.
주로 
사용자 로그인 상태
테마 설정
다국어 설정
알림
설정값
에서 유용합니다.
단, useContext는 MyContext.Provider 안에서만 사용할 수 있습니다.
그렇다면 언제 훅으로 빼야하는 걸까?
2개 이상 컴포넌트에서 사용할 경우
복잡한 비즈니스 로직일 경우
독립적 테스트가 필요할 경우
재사용이 필요한 로직을 따로 뺄 경우
훅으로 빼면 안좋은 경우
단순한 상태 ex) loading, error
한 곳에서만 사용할 경우
로직 분리는 복잡도, 재사용성에 따라 결정하고, 적절하게 사용하는 것이 중요합니다.
간략하게 리액트를 정리해보았는데,
결국 리액트는 UI를 더 쉽고 깔끔하고 예측가능하게 만들기 위해 설계된 라이브러리라는 생각이 듭니다.

[Read more](https://velog.io/@deepsea/ReactIsland)